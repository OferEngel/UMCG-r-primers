{
  "hash": "1e67aa6778ba24b0989b47ca8b1519fa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Beyond histograms\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - ggplot2\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n\n### A problem {.no-hide}\n\nBy adding a fill color to our histogram below, we've divided the data into five \"sub-distributions\": the distribution of price for Fair cut diamonds, for Good cut diamonds, for Very Good cut diamonds, for Premium cut diamonds, and for Ideal cut diamonds.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](02-beyond-histograms_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nBut this display has some shortcomings:\n\n* it is difficult to see the \"shapes\" of the individual distributions\n* it is difficult to compare the individual distributions, because they do not share a common baseline value for $y$.\n\n### A solution\n\nWe can improve the plot by using a different geom to display the distributions of price values. {ggplot2} includes three geoms that display the same information as a histogram, but in different ways:\n\n1. `geom_freqpoly()`\n1. `geom_density()`\n1. `geom_dotplot()`\n\n### `geom_freqpoly()`\n\n`geom_freqpoly()` plots a _frequency polygon_, which uses a line to display the same information as a histogram. You can think of a frequency polygon as a line that would connect the top of each bar that appears in a histogram, like this:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](02-beyond-histograms_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nNote that the bars are not part of the frequency polygon; they are just there for reference. `geom_freqpoly()` recognizes the same parameters as `geom_histogram()`, such as `bins`, `binwidth`, and `boundary`.\n\n### Exercise 6: Frequency polygons\n\nCreate the frequency polygon depicted above. It has a `binwidth` of 0.25 and starts at the `boundary` zero.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = diamonds) +\n  geom_freqpoly(mapping = aes(x = carat), binwidth = 0.25, boundary = 0)\n```\n\n:::\n\n###\n\nGood job! By using a line instead of bars, frequency polygons can sometimes do things that histograms cannot.\n\n\n### Exercise 7: Multiple frequency polygons\n\nUse a frequency polygon to replace our chart of price and cut. Since lines do not have \"substance\" like bars, you will want to use the color aesthetic instead of the fill aesthetic.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](02-beyond-histograms_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = diamonds) +\n  geom_freqpoly(mapping = aes(x = price, color = cut), binwidth = 1000, boundary = 0)\n```\n\n:::\n\n###\n\nGood job! Since lines do not occlude each other, `geom_freqpoly()` plots each subgroup against the same baseline: `y = 0` (i.e. it unstacks the subgroups). This makes it easier to compare the distributions. You can now see that for almost every price value, there are more Ideal cut diamonds than there are other types of diamonds.\n\n### `geom_density()`\n\nOur frequency polygon highlights a second shortcoming with our graph: it is difficult to compare the shapes of the distributions because some subgroups contain more diamonds than others. This compresses smaller subgroups into the bottom of the graph.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](02-beyond-histograms_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nYou can avoid this with `geom_density()`.\n\n### Density curves\n\n`geom_density()` plots a kernel density estimate (i.e. a density curve) for each distribution. This is a smoothed representation of the data, analogous to a smoothed histogram. \n\nDensity curves do not plot count on the $y$ axis but _density_, which is analogous to the count divided by the total number of observations. Densities makes it easy to compare the distributions of subgroups. When you plot multiple subgroups, each density curve will contain the same area under its curve.\n\n\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](02-beyond-histograms_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](02-beyond-histograms_files/figure-html/unnamed-chunk-6-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n### Exercise 8: Density curves\n\nRe-draw this histogram with density curves. How do you interpret the results?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](02-beyond-histograms_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = diamonds) +\n  geom_density(mapping = aes(x = price, color = cut))\n```\n\n:::\n\n###\n\nGood job! You can now compare the most common prices for each subgroup. For example, the plot shows that the most common price for most diamonds is near \\$1000. However, the most common price for Fair cut diamonds is significantly higher, about \\$2500. We will come back to this oddity in a later tutorial.\n\n### Density parameters\n\nDensity plots do not take `bin`, `binwidth`, and `boundary` parameters. Instead they recognize kernel and smoothing parameters that are used in the density fitting algorithm, which is fairly sophisticated. \n\nIn practice, you can obtain useful results quickly with the default parameters of `geom_density()`. If you'd like to learn more about density estimates and their tuning parameters, begin with the help page at `?geom_density()`.\n\n### `geom_dotplot()`\n\nggplot2 provides a final geom for displaying one dimensional distributions: `geom_dotplot()`. `geom_dotplot()` represents each observation with a dot and then stacks dots within bins to create the semblance of a histogram.\n\nDotplots can provide an intuitive display of the data, but they have several shortcomings. Dotplots are not ideal for large data sets like `diamonds`, and provide meaningless $y$ axis labels. I also find that the tuning parameters of `geom_dotplot()` make dotplots too slow to work with for EDA.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(data = mpg) +\n  geom_dotplot(mapping = aes(x = displ), dotsize = 0.5, stackdir = \"up\", stackratio = 1.1)\n\n\n```\n\n:::\n\n### Exercise 9: Facets\n\nInstead of changing geoms, you can make the subgroups in our original plot easier to compare by facetting the data. Extend the code below to facet by cut.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(data = diamonds) +\n  geom_histogram(mapping = aes(x = price, fill = cut), binwidth = 1000, boundary = 0)\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = diamonds) +\n  geom_histogram(mapping = aes(x = price, fill = cut), binwidth = 1000, boundary = 0) +\n  facet_wrap(vars(cut))\n```\n\n:::\n\n###\n\nGood job! Facets make it easier to compare subgroups, but at the expense of separating the data. You may decide that frequency polygons and densities allow more direct comparisons.\n\n### Recap\n\nIn this tutorial, you learned how to visualize distributions with histograms, frequency polygons, and densities. But what should you look for in these visualizations?\n\n* **Look for places with lots of data.** Tall bars reveal the most common values in your data; you can expect these values to be the \"typical values\" for your variable.\n\n* **Look for places with little data.** Short bars reveal uncommon values. These values appear rarely and you might be able to figure out why.\n\n* **Look for outliers.** Bars that appear away from the bulk of the data are outliers, special cases that may reveal unexpected insights. \n    \n  Sometimes outliers cannot be seen in a plot, but can be inferred from the range of the $x$ axis. For example, many of the plots in this tutorial seemed to extend well past the end of the data. Why? Because the range was stretched to include outliers. When your data set is large, like `diamonds`, the bar that describes an outlier may be invisible (i.e. less than one pixel high).\n    \n* **Look for clusters.**\n\n* **Look for shape.** The shape of a histogram can often indicate whether or not a variable behaves according to a known probability distribution.\n\nThe most important thing to remember about histograms, frequency polygons, and dotplots is to explore different binwidths. The binwidth of a histogram determines what information the histogram displays. You cannot predict ahead of time which binwidth will reveal unexpected information.\n\n\n##\n\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n<a id=\"nextTopicButton\" class=\"btn btn-danger disabled\" href=\"03-boxplots.html\" role=\"button\">Next topic</a>\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [
      "02-beyond-histograms_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}