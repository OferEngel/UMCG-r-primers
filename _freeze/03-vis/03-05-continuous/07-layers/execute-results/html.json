{
  "hash": "d92f2a2d2f83e48cb593f72570ce1b25",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Layers\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  repos:\n    - https://slowkow.r-universe.dev\n  packages:\n    - ggplot2\n    - dplyr\n    - ggrepel\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n\n### Add a layer {.no-hide}\n\n`geom_smooth()` becomes much more useful when you combine it with `geom_point()` to create a scatterplot that contains both:\n\n* raw data\n* a trend line\n\nIn {ggplot2}, you can add multiple geoms to a plot by adding multiple geom functions to the plot call. For example, the code below creates a plot that contains both points and a smooth line. Imagine what the results will look like in your head, and then run the code to see if you are right.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nmpg |> \n  group_by(class) |> \n  summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) |> \n  ggplot() +\n    geom_point(mapping = aes(x = mean_cty, y = mean_hwy)) +\n    geom_smooth(mapping = aes(x = mean_cty, y = mean_hwy), method = \"lm\")\n\n\n```\n\n:::\n\n###\n\nGood job! You can add as many geom functions as you like to a plot; but, in practice, a plot will become hard to interpret if it contains more than two or three geoms.\n\n\n### `geom_label_repel()`\n\nDo you remember how the labels that we made early overlapped each other and ran off our graph? The `geom_label_repel()` geom from the {ggrepel} package mitigates these problems by using an algorithm to arrange labels within a plot. It works best in conjunction with a layer of points that displays the true location of each observation.\n\nUse `geom_label_repel()` to add a new layer to our plot below. `geom_label_repel()` requires the same aesthetics as `geom_label()`: `x`, `y`, and `label` (here set to `class`).\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nmpg |> \n  group_by(class) |> \n  summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) |> \n  ggplot() +\n    geom_point(mapping = aes(x = mean_cty, y = mean_hwy)) +\n    geom_smooth(mapping = aes(x = mean_cty, y = mean_hwy), method = \"lm\")\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nmpg |> \n  group_by(class) |> \n  summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) |> \n  ggplot() +\n    geom_point(mapping = aes(x = mean_cty, y = mean_hwy)) +\n    geom_smooth(mapping = aes(x = mean_cty, y = mean_hwy), method = \"lm\") +\n    geom_label_repel(mapping = aes(x = mean_cty, y = mean_hwy, label = class))\n```\n\n:::\n\n###\n\nGood job! The {ggrepel} package also provides `geom_text_repel()`, which is an analogue for `geom_text()`.\n\n### Code duplication\n\nIf you study the solution for the previous exercise, you'll notice a fair amount of duplication. We set the same aesthetic mappings in three different places.\n\n```r\nmpg |> \n  group_by(class) |> \n  summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) |> \n  ggplot() +\n    geom_point(mapping = aes(x = mean_cty, y = mean_hwy)) +\n    geom_smooth(mapping = aes(x = mean_cty, y = mean_hwy), method = \"lm\") +\n    geom_label_repel(mapping = aes(x = mean_cty, y = mean_hwy, label = class))\n```\n\nYou should try to avoid duplication whenever you can in code because duplicated code invites typos, is hard to update, and takes longer than needed to write. Thankfully, {ggplot2} provides a way to avoid duplication across multiple layers.\n\n### `ggplot()` mappings\n\nYou can set aesthetic mappings in two places within any {ggplot2} call. You can set the mappings inside of a geom function, as we've been doing. Or you can set the mappings inside of the `ggplot()` function like below:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n### Global vs. local mappings\n\n{ggplot2} will treat any mappings set in the `ggplot()` function as _global_ mappings. Each layer in the plot will inherit and use these mappings. \n\n{ggplot2} will treat any mappings set in a geom function as _local_ mappings. Only the local layer will use these mappings. The mappings will override the global mappings if the two conflict, or add to them if they do not.\n\nThis system creates an efficient way to write plot calls:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth(mapping = aes(color = class), se = FALSE)\n```\n\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n### Exercise 2\n\nReduce duplication in the code below by moving as many local mappings into the global mappings as possible. Rerun the new code to ensure that it creates the same plot.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nmpg |> \n  group_by(class) |> \n  summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) |> \n  ggplot() +\n    geom_point(mapping = aes(x = mean_cty, y = mean_hwy)) +\n    geom_smooth(mapping = aes(x = mean_cty, y = mean_hwy), method = \"lm\") +\n    geom_label_repel(mapping = aes(x = mean_cty, y = mean_hwy, label = class))\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nmpg |> \n  group_by(class) |> \n  summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) |> \n  ggplot(mapping = aes(x = mean_cty, y = mean_hwy)) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    geom_label_repel(mapping = aes(label = class))\n```\n\n:::\n\n###\n\nGood job! Remember that not every mapping should be a global mapping. Here, only `geom_label_repel()` uses the `label` aesthetic. Hence, it should remain a local aesthetic to avoid unintended side effects, warnings, or errors.\n\n\n### Exercise 3: Global vs. Local\n\nRecreate the plot below in the most efficient way possible.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point(mapping = aes(color = class)) +\n  geom_smooth()\n```\n\n:::\n\n###\n\nGood job!\n\n\n### Global vs. local data\n\nThe `data` argument also follows a global vs. local system. If you set the `data` argument of a geom function, the geom will use the data you supply instead of the data contained in `ggplot()`. This is a convenient way to highlight groups of points.\n\nUse `data` arguments to recreate the plot below. I've started the code for you.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nmpg2 <- filter(mpg, class == \"2seater\")\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nmpg2 <- filter(mpg, class == \"2seater\")\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_point(data = mpg2, color = \"red\", size = 2)\n```\n\n:::\n\n###\n\nGood job!\n\n\n### Exercise 4: Global vs. local data\n\nUse `data` arguments to recreate the plot below.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nmpg3 <- filter(mpg, hwy > 40)\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_label_repel(data = mpg3, mapping = aes(label = class))\n```\n\n:::\n\n###\n\nGood job!\n\n\n### `last_plot()`\n\nWhen exploring data, you'll often make a plot and then think of a way to improve it. Instead of starting from scratch or copying and pasting your code, you can use {ggplot2}'s `last_plot()` function. `last_plot()` returns the most recent plot call, which makes it easy to build up a plot one layer at a time.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\nlast_plot() +\n  geom_smooth()\n```\n\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-7-2.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\nlast_plot() +\n  geom_smooth(method = \"lm\", color = \"purple\")\n```\n\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-7-3.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n### Saving plots\n\nIf you'd like to work with a plot later, you can save it to an R object. Later you can display the plot or add to it, as if you were using `last_plot()`. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np <- ggplot(data = mpg) +\n  geom_point(mapping = aes(x = cty, y = hwy))\n```\n:::\n\n\n\n\nNotice that {ggplot2} will not display a plot when you save it. It waits until you call the saved object.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np\n```\n\n::: {.cell-output-display}\n![](07-layers_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n\n### `geom_rug()`\n\n`geom_rug()` adds another type of summary to a plot. It uses displays the one dimensional marginal distributions of each variable in the scatterplot. These appear as collections of tickmarks along the $x$ and $y$ axes.\n\nIn the chunk below, use the `faithful` dataset to create a scatterplot that has the `waiting` variable on the $x$ axis and the `eruptions` variable on the $y$ axis. Use `geom_rug()` to add a rug plot to the scatterplot. Like `geom_point()`, `geom_rug()` requires x and y aesthetic mappings.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = faithful, mapping = aes(x = waiting, y = eruptions)) +\n  geom_point() +\n  geom_rug()\n```\n\n:::\n\n###\n\nGood job! Pass `geom_rug()` the parameter `sides = \"l\"` to limit the rug plot to just the left-hand axis (y) or `sides = \"b\"` to limit the rug plot to just the bottom axis (x).\n\n### `geom_jitter()`\n\n`geom_jitter()` plots a scatterplot and then adds a small amount of random noise to each point in the plot. It is a shortcut for adding a \"jitter\" position adjustment to a points plot (i.e, `geom_point(position = \"jitter\")`).\n\nWhy would you use `geom_jitter()`? Jittering provides a simple way to inspect patterns that occur in heavily gridded or overlapping data. To see what I mean, replace `geom_point()` with `geom_jitter()` in the plot below.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = class, y = hwy))\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = mpg) +\n  geom_jitter(mapping = aes(x = class, y = hwy))\n```\n\n:::\n\n###\n\nGood job! You can also jitter in only a single direction. To turn off jittering in the x direction set `width = 0` in `geom_jitter()`. To turn off jittering in the y direction, set `height = 0`.\n\n\n### Jittering and boxplots\n\n`geom_jitter()` provides a convenient way to overlay raw data on boxplots, which display summary information.\n\nUse the chunk below to create a boxplot of the previous graph. Arrange for the outliers to have an alpha of 0, which will make them completely transparent. Then add a layer of points that are jittered in $y$ direction, but not the $x$ direction.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot(outlier.alpha = 0) +\n  geom_jitter(width = 0)\n```\n\n:::\n\n###\n\nGood job! If you like, you can make the boxplots more visible by setting the `alpha` parameter of `geom_jitter()` to a low number, e.g. `geom_jitter(mapping = aes(x = class, y = hwy), width = 0, alpha = 0.5)`\n\n\n##\n\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n<a id=\"nextTopicButton\" class=\"btn btn-danger disabled\" href=\"08-coordinate-systems.html\" role=\"button\">Next topic</a>\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [
      "07-layers_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}