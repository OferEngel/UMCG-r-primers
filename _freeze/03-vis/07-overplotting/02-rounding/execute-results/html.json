{
  "hash": "6943bfe8d37ae8f885f9eeadf70a9e3f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Rounding\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - ggplot2\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n\n### Overplotting due to rounding {.no-hide}\n\nIf your overplotting is due to rounding, you can obtain a better picture of the data by making each point semi-transparent. For example you could _set_ the `alpha` aesthetic of the plot below to a _value_ less than one, which will make the points transparent. \n\nTry this now. Set the points to an alpha of 0.25, which will make each point 25% opaque (i.e. four points staked on top of each other will create a solid black).\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n\n\n```\n\n## {{< fa lightbulb >}}&ensp;Hint\n\n**Hint:** Make sure you set `alpha = 0.25` *outside* of `aes()`.\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy), alpha = 0.25)\n```\n\n:::\n\n###\n\nGood job! You can now identify which values contain more observations. The darker locations contain several points stacked on top of each other.\n\n\n### Adjust the position\n\nA second strategy for dealing with rounding is to adjust the position of each point. `position = \"jitter\"` adds a small amount of random noise to the location of each point. Since the noise is random, it is unlikely that two points rounded to the same location will also be jittered to the same location.\n\nThe result is a jittered plot that displays more of the data. Jittering comes with both limitations and benefits. You cannot use a jittered plot to see the _local_ values of the points, but you can use a jittered plot to perceive the _global_ relationship between the variables, something that is hard to do in the presence of overplotting.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy), position = \"jitter\")\n```\n\n::: {.cell-output-display}\n![](02-rounding_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n### Review: jitter\n\nIn the [Scatterplots tutorial](/03-viz/07-layers.html), you learned of a geom that displays the equivalent of `geom_point()` with a `position = \"jitter\"` adjustment.\n\nRewrite the code below to use that geom. Do you obtain similar results?\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy), position = \"jitter\")\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(data = mpg) +\n  geom_jitter(mapping = aes(x = displ, y = hwy))\n```\n\n:::\n\n###\n\nGood job! Now let's look at ways to handle overplotting due to large datasets.\n\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n<a id=\"nextTopicButton\" class=\"btn btn-danger disabled\" href=\"03-large-data.html\" role=\"button\">Next topic</a>\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [
      "02-rounding_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}