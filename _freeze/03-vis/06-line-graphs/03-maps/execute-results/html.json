{
  "hash": "ec6cdb94e1acfbbdf7a4821ff59a9fee",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Maps\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - ggplot2\n    - dplyr\n    - tibble\n    - sf\n    - spData\n    - maps\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n```{webr-r}\n#| context: setup\nus <- map_data(\"state\")\n\nUSArrests2 <- USArrests |> \n  rownames_to_column(\"NAME\")\n\nus_states_merged <- us_states |> \n  left_join(USArrests2, by = join_by(NAME))\n\nus_states_merged\n```\n\n\n### {maps}: the older way to make maps with R {.no-hide}\n\nThe `tx` data set comes from the {maps} package, which is an R package that contains similarly formatted data sets for many regions of the globe. \n\nA short list of the datasets saved in maps includes: `france`, `italy`, `nz`, `usa`, `world`, and `world2`, along with `county` and `state`. These last two map the US at the county and state levels. To learn more about maps, run `help(package = maps)`.\n\n### `map_data()`\n\nYou do not need to access the {maps} package to use its data. {ggplot2} provides the function `map_data()` which fetches maps from the maps package and returns them in a format that {ggplot2} can plot. \n\nTo use `map_data()` give it the name of a dataset to retrieve. You can retrieve a subset of the data by providing an optional `region` argument. For example, I can use this code to retrieve a map of Florida from `state`, which is the dataset that contains all 50 US states.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfl <- map_data(\"state\", region = \"florida\")\n\nggplot(fl) +\n  geom_polygon(mapping = aes(x = long, y = lat))\n```\n:::\n\n\n\nAlter the code to retrieve and plot your home state (Try Idaho if you are outside of the US). Notice the capitalization.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nid <- map_data(\"state\", region = \"idaho\")\n\nggplot(id) +\n  geom_polygon(mapping = aes(x = long, y = lat))\n```\n\n:::\n\n###\n\nGood job! This is how I collected the `tx` dataset. Let's look at what would happen if you do not specify a region in `map_data()`.\n\n### state\n\nIf you do not specify a region, `map_data()` will retrieve the entire data set, in this case `state`. \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nus <- map_data(\"state\")\n```\n:::\n\n\n\nIn practice, you will often have to retrieve an entire dataset at least once to learn what region names to use with `map_data()`. The names will be stored in the `region` column of the dataset.\n\n### Hmmm\n\nThe code below retrieves and plots the entire state data set, but something goes wrong. What?\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nus <- map_data(\"state\")\n\nggplot(us) +\n  geom_polygon(mapping = aes(x = long, y = lat))\n```\n\n::: {.cell-output-display}\n![](03-maps_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n### Multiple polygons\n\nIn this case, our data is not out of order, but it contains more than one polygon: it contains 50 polygons---one for each state. \n\nBy default, `geom_polygon()` tries to plot a single polygon, which causes it to connect multiple polygons in weird ways. \n\n### groups\n\nWhich aesthetic can you use to plot multiple polygons? In the code below, map the `group` aesthetic to the `group` variable in the `state` dataset. This variable contains all of the grouping information needed to make a coherent map. Then rerun the code.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(us) +\n  geom_polygon(mapping = aes(x = long, y = lat))\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(us) +\n  geom_polygon(mapping = aes(x = long, y = lat, group = group))\n```\n\n:::\n\n###\n\nGood job! You've mastered one method for drawing maps. This approach is older, though, and far less flexible than the more modern approach, which uses the {sf} package.\n\n### {sf}, or \"simple features\"\n\nThe [{sf} package](https://r-spatial.github.io/sf/) (\"sf\" = [\"simple features\"](https://en.wikipedia.org/wiki/Simple_Features)) is the new *de facto* system for doing anything with geographic data with R. \n\nFully exploring {sf} here goes beyond the scope of these tutorials, but there are a ton of resources online about it:\n\n- [{sf} documentation](https://r-spatial.github.io/sf/)\n- [Chapter 6](https://ggplot2-book.org/maps.html#sec-sf) in the 3rd edition of *ggplot2: Elegant Graphics for Data Analysis*\n- [Lightning quick overview of {sf} and shapefiles](https://www.andrewheiss.com/blog/2023/04/26/middle-earth-mapping-sf-r-gis/#lightning-quick-overview-of-sf-and-shapefiles)\n- [*Spatial Data Science*](https://r-spatial.org/book/)\n- [*Geocomputation with R*](https://r.geocompx.org/)\n\nWe'll just explore it a little bit here.\n\n### Why {sf}?\n\nThe data that comes from `map_data()` contains columns for latitude and longitude, which represent geographic data. However, geographic data is a lot more complex than just x/y coordinates. \n\n1. The latitude and longitude coordinates in datasets like `tx` and `us` that we've been using are just individual rows. You could accidentally filter out some rows and remove portions of the border. It would be nice if the coordinates for a state stayed together in one object\n1. As we've seen, we can use `geom_polygon()` or `geom_path()` to connect the dots between latitude and longitude coordinates, but those rows **must** be in the correct order to work. {ggplot2} has `geom_map()`, which is like `geom_polygon()` and `geom_path()`, but doesn't require that the order is correct, but it's tricky to incorporate other data into it. Suppose you want to fill each state by some other variable, like crime rates or median income—you need to somehow get that data into the map and display in the state polygons.\n1. Any time you take a section of a globe and flatten it into a two-dimensional map, you have to decide how to project the roundness into something flat, which changes the shapes of the geographic elements of a map. You probably noticed that the maps we've created so far with `geom_polygon()` and `geom_path()` look squished and incorrect. We're not using map projections to ensure they're flattened correctly or treated as actual map coordinates.\n\n### {sf} saves the day\n\nThe {sf} package solves all these problems.\n\n1. Geographic coordinates in {sf}-enabled datasets aren't stored as separate latitude and longitude columns. Instead, they're kept in a special column named `geometry`. This makes it so you can have one row per unit of analysis (country, state, county, province, etc.) instead of thousands of rows.\n1. Since there's one row per unit of analysis, it's a lot easier to merge in other data.\n1. The `geom_sf()` geom uses the special `geometry` column to plot the coordinates.\n1. The `coord_sf()` layer ensures that the map uses specific projections (and lets you change to different projections) so that your maps don't get distorted.\n\nLet's see how this works.\n\n### {sf}-enabled data\n\nThe `us` data we created with `map_data()` won't work with {sf}, since it's just a bunch of x/y coordinates. But we can load the `us_states` dataset from [the {spData} package](https://jakubnowosad.com/spData/):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(spData)\nus_states\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 49 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 24.55868 xmax: -66.9824 ymax: 49.38436\nGeodetic CRS:  NAD83\nFirst 10 features:\n   GEOID        NAME   REGION             AREA total_pop_10 total_pop_15\n1     01     Alabama    South 133709.27 [km^2]      4712651      4830620\n2     04     Arizona     West 295281.25 [km^2]      6246816      6641928\n3     08    Colorado     West 269573.06 [km^2]      4887061      5278906\n4     09 Connecticut Norteast  12976.59 [km^2]      3545837      3593222\n5     12     Florida    South 151052.01 [km^2]     18511620     19645772\n6     13     Georgia    South 152725.21 [km^2]      9468815     10006693\n7     16       Idaho     West 216512.66 [km^2]      1526797      1616547\n8     18     Indiana  Midwest  93648.40 [km^2]      6417398      6568645\n9     20      Kansas  Midwest 213037.08 [km^2]      2809329      2892987\n10    22   Louisiana    South 122345.76 [km^2]      4429940      4625253\n                         geometry\n1  MULTIPOLYGON (((-88.20006 3...\n2  MULTIPOLYGON (((-114.7196 3...\n3  MULTIPOLYGON (((-109.0501 4...\n4  MULTIPOLYGON (((-73.48731 4...\n5  MULTIPOLYGON (((-81.81169 2...\n6  MULTIPOLYGON (((-85.60516 3...\n7  MULTIPOLYGON (((-116.916 45...\n8  MULTIPOLYGON (((-87.52404 4...\n9  MULTIPOLYGON (((-102.0517 4...\n10 MULTIPOLYGON (((-92.01783 2...\n```\n\n\n:::\n:::\n\n\n\nNotice how it looks different from the `tx` and `us` data. There's one row for each state, and the geographic data for each state is stored in the `geometry` column\n\n### `geom_sf()`\n\nThat `geometry` column is special. When we use it with `geom_sf()`, {ggplot2} will automatically convert it into polygons. If `geometry` contains points, like city coordinates, `geom_sf()` will plot them as points; if `geometry` contains lines, like roads, `geom_sf()` will plot them as lines.\n\nTry running this to see what happens:\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot() +\n  geom_sf(data = us_states)\n\n\n```\n\n:::\n\n### \n\nThat's really neat! We didn't need to worry about the order of the rows in the dataset, and the map isn't distorted.\n\n### Manipulating {sf}-enabled data\n\nBecause {sf}-enabled datasets are tibbles, all our {dplyr} verbs work on them. For example, we can use `filter()` to select and plot just Texas:\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nus_states |> \n  filter(NAME == \"Texas\") |> \n  ggplot() +\n    geom_sf()\n\n\n```\n\n:::\n\n### Plotting data on maps\n\nR comes with a data set named `USArrests` that we can use to make a _choropleth map_. A choropleth map uses the color of each region in the plot to display some value associated with the region.\n\nIn our case we will use the `UrbanPop` variable of `USAarrests` which records how urbanized each state was in 1973. `UrbanPop` is the percent of the population who lived within a city.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nUSArrests\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50 × 4\n   Murder Assault UrbanPop  Rape\n    <dbl>   <int>    <int> <dbl>\n 1   13.2     236       58  21.2\n 2   10       263       48  44.5\n 3    8.1     294       80  31  \n 4    8.8     190       50  19.5\n 5    9       276       91  40.6\n 6    7.9     204       78  38.7\n 7    3.3     110       77  11.1\n 8    5.9     238       72  15.8\n 9   15.4     335       80  31.9\n10   17.4     211       60  25.8\n# ℹ 40 more rows\n```\n\n\n:::\n:::\n\n\n\n### Data wrangling\n\nYou can use `geom_sf()` to create choropleth maps. To use `geom_sf()`, we need to merge or join `USArrests` with a dataset that contains geographic information for each state. \n\nWe need to combine `USArrests` with `us_states` to make this work. Joining datasets goes beyond the scope of this tutorial—I'll just show how it's done here. We'll use `left_join()` to add all the columns from `USArrests` to `us_states` wherever the two datasets share a state name. \n\nThis means the two datasets need to share a state name, and right now, this isn't the case. `us_states` has a `NAME` column, and `USArrests` hides its state names outside of the dataset in the row names (instead of in a column). In contrast, `us` uses a column of lower case state names.\n\nThis converts the rownames in `USArrests` to a column named `NAME` and then combines it with `us_states`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nUSArrests2 <- USArrests |> \n  rownames_to_column(\"NAME\")\n\nus_states_merged <- us_states |> \n  left_join(USArrests2, by = join_by(NAME))\n\nus_states_merged\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 49 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 24.55868 xmax: -66.9824 ymax: 49.38436\nGeodetic CRS:  NAD83\nFirst 10 features:\n   GEOID        NAME   REGION             AREA total_pop_10 total_pop_15 Murder\n1     01     Alabama    South 133709.27 [km^2]      4712651      4830620   13.2\n2     04     Arizona     West 295281.25 [km^2]      6246816      6641928    8.1\n3     08    Colorado     West 269573.06 [km^2]      4887061      5278906    7.9\n4     09 Connecticut Norteast  12976.59 [km^2]      3545837      3593222    3.3\n5     12     Florida    South 151052.01 [km^2]     18511620     19645772   15.4\n6     13     Georgia    South 152725.21 [km^2]      9468815     10006693   17.4\n7     16       Idaho     West 216512.66 [km^2]      1526797      1616547    2.6\n8     18     Indiana  Midwest  93648.40 [km^2]      6417398      6568645    7.2\n9     20      Kansas  Midwest 213037.08 [km^2]      2809329      2892987    6.0\n10    22   Louisiana    South 122345.76 [km^2]      4429940      4625253   15.4\n   Assault UrbanPop Rape                       geometry\n1      236       58 21.2 MULTIPOLYGON (((-88.20006 3...\n2      294       80 31.0 MULTIPOLYGON (((-114.7196 3...\n3      204       78 38.7 MULTIPOLYGON (((-109.0501 4...\n4      110       77 11.1 MULTIPOLYGON (((-73.48731 4...\n5      335       80 31.9 MULTIPOLYGON (((-81.81169 2...\n6      211       60 25.8 MULTIPOLYGON (((-85.60516 3...\n7      120       54 14.2 MULTIPOLYGON (((-116.916 45...\n8      113       65 21.0 MULTIPOLYGON (((-87.52404 4...\n9      115       66 18.0 MULTIPOLYGON (((-102.0517 4...\n10     249       66 22.2 MULTIPOLYGON (((-92.01783 2...\n```\n\n\n:::\n:::\n\n\n\nWe've now added four new columns to `us_states`, including `UrbanPop`. \n\n### `geom_sf()` and aesthetics\n\nNow that we have `UrbanPop` in our data, we can use it as an aesthetic. Try adding `aes(fill = UrbanPop)` to `geom_sf()` here:\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(us_states_merged) +\n  geom_sf()\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nggplot(us_states_merged) +\n  geom_sf(aes(fill = UrbanPop))\n```\n\n:::\n\n###\n\nCongratulations! You've used geom_map() to make your first choropleth plot! To test your understanding, alter the code to display the `Murder`, `Assault`, or `Rape` variables.\n\n### Projections\n\nTaking a three-dimensional globe and flattening it to a two-dimensional surface means that map shapes will always be different, depending on which way you flatten them. You can control how things are flattened using different map projections. There are standard indexes of more than 4,000 of these projections at [epsg.io](https://epsg.io/).\n\nHere are some common ones:\n\n- [EPSG:3395](http://epsg.io/3395): Mercator projection for the world\n- [ESRI:54008](http://epsg.io/54008): Sinusoidal projection for the world\n- [ESRI:54009](http://epsg.io/54009): Mollweide projection for the world\n- [ESRI:54030](http://epsg.io/54030): Robinson projection for the world\n- [EPSG:4326](http://epsg.io/4326): WGS 84: DOD GPS coordinates (standard −180 to 180 system)\n- [EPSG:4269](http://epsg.io/4269): NAD 83: Relatively common projection for North America\n- [ESRI:102003](https://epsg.io/102003): Albers projection specifically for the contiguous United States\n\n### Changing projections\n\nBy default, `geom_sf()` will display the map using whatever projection system is embedded in the `geometry` column. In the case of `us_states` and `us_states_merged`, this is https://en.wikipedia.org/wiki/North_American_Datum or [EPSG:4269](http://epsg.io/4269). You can tell by looking at the `Geodetic CRS` line near the top of the output from `us_states_merged`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nus_states_merged\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 49 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 24.55868 xmax: -66.9824 ymax: 49.38436\nGeodetic CRS:  NAD83\nFirst 10 features:\n   GEOID        NAME   REGION             AREA total_pop_10 total_pop_15 Murder\n1     01     Alabama    South 133709.27 [km^2]      4712651      4830620   13.2\n2     04     Arizona     West 295281.25 [km^2]      6246816      6641928    8.1\n3     08    Colorado     West 269573.06 [km^2]      4887061      5278906    7.9\n4     09 Connecticut Norteast  12976.59 [km^2]      3545837      3593222    3.3\n5     12     Florida    South 151052.01 [km^2]     18511620     19645772   15.4\n6     13     Georgia    South 152725.21 [km^2]      9468815     10006693   17.4\n7     16       Idaho     West 216512.66 [km^2]      1526797      1616547    2.6\n8     18     Indiana  Midwest  93648.40 [km^2]      6417398      6568645    7.2\n9     20      Kansas  Midwest 213037.08 [km^2]      2809329      2892987    6.0\n10    22   Louisiana    South 122345.76 [km^2]      4429940      4625253   15.4\n   Assault UrbanPop Rape                       geometry\n1      236       58 21.2 MULTIPOLYGON (((-88.20006 3...\n2      294       80 31.0 MULTIPOLYGON (((-114.7196 3...\n3      204       78 38.7 MULTIPOLYGON (((-109.0501 4...\n4      110       77 11.1 MULTIPOLYGON (((-73.48731 4...\n5      335       80 31.9 MULTIPOLYGON (((-81.81169 2...\n6      211       60 25.8 MULTIPOLYGON (((-85.60516 3...\n7      120       54 14.2 MULTIPOLYGON (((-116.916 45...\n8      113       65 21.0 MULTIPOLYGON (((-87.52404 4...\n9      115       66 18.0 MULTIPOLYGON (((-102.0517 4...\n10     249       66 22.2 MULTIPOLYGON (((-92.01783 2...\n```\n\n\n:::\n:::\n\n\n\nTo use a different projection, set the `crs` argument of `coord_sf()` to a projection ID from [epsg.io](https://epsg.io/).\n\nFor example, here's our US map with an [Albers projection](https://epsg.io/102003), which is [specifically designed for North America](https://en.wikipedia.org/wiki/Albers_projection):\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nggplot(us_states_merged) +\n  geom_sf(aes(fill = UrbanPop)) +\n  coord_sf(crs = st_crs(\"ESRI:102003\"))\n\n\n```\n\n:::\n\n### Recap\n\nYou can now make all of the plots recommended in the [Exploratory Data Analysis tutorial](/visualize-data/01-eda/). The next tutorial in this primer will teach you several strategies for dealing with overplotting, a problem that can occur when you have large data or low resolution data.\n\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [
      "03-maps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}