{
  "hash": "507d96fe735f39e8725df28ed8398caf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"`|>`\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - babynames\n    - dplyr\n    - ggplot2\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n\n### Steps {.no-hide}\n\nNotice how each {dplyr} function takes a data frame as input and returns a data frame as output. This makes the functions easy to use in a step-by-step fashion. For example, you could:\n\n1. Filter `babynames` to just boys born in 2017\n2. Select the `name` and `n` columns from the result\n3. Arrange those columns so that the most popular names appear near the top.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nboys_2017 <- filter(babynames, year == 2017, sex == \"M\")\nboys_2017 <- select(boys_2017, name, n)\nboys_2017 <- arrange(boys_2017, desc(n))\nboys_2017\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,160 × 2\n   name         n\n   <chr>    <int>\n 1 Liam     18728\n 2 Noah     18326\n 3 William  14904\n 4 James    14232\n 5 Logan    13974\n 6 Benjamin 13733\n 7 Mason    13502\n 8 Elijah   13268\n 9 Oliver   13141\n10 Jacob    13106\n# ℹ 14,150 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### Redundancy\n\nThe result shows us the most popular boys names from 2017, which is the most recent year in the data set. But take a look at the code. Do you notice how we re-create `boys_2017` at each step so we will have something to pass to the next step? This is an inefficient way to write R code.\n\nYou could avoid creating `boys_2017` by nesting your functions inside of each other, but this creates code that is hard to read:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\narrange(select(filter(babynames, year == 2017, sex == \"M\"), name, n), desc(n))\n```\n:::\n\n\n\n\nThere is a third way to write sequences of functions: the pipe.\n\n### |>\n\nThe pipe operator `|>` performs an extremely simple task: it passes the result on its left into the first argument of the function on its right. Or put another way, `x |> f(y)` is the same as `f(x, y)`. This piece of code punctuation makes it easy to write and read series of functions that are applied in a step by step way. For example, we can use the pipe to rewrite our code above:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |> \n  filter(year == 2017, sex == \"M\") |> \n  select(name, n) |> \n  arrange(desc(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,160 × 2\n   name         n\n   <chr>    <int>\n 1 Liam     18728\n 2 Noah     18326\n 3 William  14904\n 4 James    14232\n 5 Logan    13974\n 6 Benjamin 13733\n 7 Mason    13502\n 8 Elijah   13268\n 9 Oliver   13141\n10 Jacob    13106\n# ℹ 14,150 more rows\n```\n\n\n:::\n:::\n\n\n\n\nAs you read the code, pronounce `|>` as **\"and then\"**. You'll notice that {dplyr} makes it easy to read pipes. Each function name is a verb, so our code resembles the statement, \"Take `babynames`, _and then_ filter it by `name` and `sex`, _and then_ select the `name` and `n` columns, _and then_ arrange the results by descending values of `n`.\"\n\n{dplyr} also makes it easy to write pipes. Each {dplyr} function returns a data frame that can be piped into another {dplyr} function, which will accept the data frame as its first argument. In fact, {dplyr} functions are written with pipes in mind: each function does one simple task. {dplyr} expects you to use pipes to combine these simple tasks to produce sophisticated results.\n\n### Exercise: Pipes\n\nI'll use pipes for the remainder of the tutorial, and I will expect you to as well. Let's practice a little by writing a new pipe in the chunk below. The pipe should:\n\n1. Filter `babynames` to just the *girls* that were born in 2017\n2. Select the `name` and `n` columns\n3. Arrange the results so that the most popular names are near the top.\n\nTry to write your pipe without copying and pasting the code from above.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  filter(year == 2017, sex == \"F\") |> \n  select(name, n) |> \n  arrange(desc(n))\n```\n\n:::\n\n### Your name\n\nYou've now mastered a set of skills that will let you easily plot the popularity of your name over time. In the code chunk below, use a combination of {dplyr} and {ggplot2} functions with `|>` to:\n\n1. Trim `babynames` to just the rows that contain your name and your sex\n2. Trim the result to just the columns that will appear in your graph (not strictly necessary, but useful practice)\n3. Plot the results as a line graph with `year` on the x axis and `prop` on the y axis\n\nNote that the first argument of `ggplot()` takes a data frame, which means you can add `ggplot()` directly to the end of a pipe. However, you will need to switch from `|>` to `+` to finish adding layers to your plot.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  filter(name == \"Topher\", sex == \"M\") |> \n  select(year, prop) |> \n  ggplot() +\n    geom_line(aes(x = year, y = prop)) +\n    labs(title = \"Popularity of the name Topher\")\n```\n\n:::\n\n### Recap\n\nTogether, `select()`, `filter()`, and `arrange()` let you quickly find information displayed within your data.\n\nThe next tutorial will show you how to derive information that is implied by your data, but not displayed within your data set.\n\nIn that tutorial, you will continue to use the `|>` operator, which is an essential part of programming with the dplyr library.\n\nPipes help make R expressive, like a spoken language. Spoken languages consist of simple words that you combine into sentences to create sophisticated thoughts.\n\nIn the tidyverse, functions are like words: each does one simple task well. You can combine these tasks into pipes with `|>` to perform complex, customized procedures.\n\n\n##\n\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}