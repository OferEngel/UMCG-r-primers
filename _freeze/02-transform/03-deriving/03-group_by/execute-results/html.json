{
  "hash": "d6675b857c751cbcae9b96694f3e6a07",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"`group_by()` and `summarize()`\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - babynames\n    - dplyr\n    - ggplot2\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n```{webr-r}\n#| context: setup\ntops <- babynames::babynames |> \n  group_by(name, sex) |> \n  summarise(total = sum(n)) |> \n  ungroup() |> \n  top_n(10, total)\n  \ntop_10 <- babynames::babynames |> \n  semi_join(tops, by = c(\"name\", \"sex\"))\n```\n\n`group_by()` takes a data frame and then the names of one or more columns in the data frame. It returns a copy of the data frame that has been \"grouped\" into sets of rows that share identical combinations of values in the specified columns. \n\n### `group_by()` in action\n\nFor example, the result below is grouped into rows that have the same combination of `year` and `sex` values: boys in 1880 are treated as one group, girls in 1880 as another group and so on.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  group_by(year, sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,924,665 × 5\n# Groups:   year, sex [276]\n    year sex   name          n   prop\n   <dbl> <chr> <chr>     <int>  <dbl>\n 1  1880 F     Mary       7065 0.0724\n 2  1880 F     Anna       2604 0.0267\n 3  1880 F     Emma       2003 0.0205\n 4  1880 F     Elizabeth  1939 0.0199\n 5  1880 F     Minnie     1746 0.0179\n 6  1880 F     Margaret   1578 0.0162\n 7  1880 F     Ida        1472 0.0151\n 8  1880 F     Alice      1414 0.0145\n 9  1880 F     Bertha     1320 0.0135\n10  1880 F     Sarah      1288 0.0132\n# ℹ 1,924,655 more rows\n```\n\n\n:::\n:::\n\n\n\n### Using `group_by()`\n\nBy itself, `group_by()` doesn't do much. It assigns grouping criteria that is stored as metadata alongside the original data set. If your dataset is a tibble, as above, R will tell you that the data is grouped at the top of the tibble display. In all other aspects, the data looks the same.\n\nHowever, when you apply a {dplyr} function like `summarize()` to grouped data, dplyr will execute the function in a groupwise manner. Instead of computing a single summary for the entire data set, {dplyr} will compute individual summaries for each group and return them as a single data frame. The data frame will contain the summary columns as well as the columns in the grouping criteria, which makes the result decipherable\n\nWatch these animations to see what happens with one group:\n\n::: {.panel-tabset}\n## `group_by(cat1)`\n\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"video/grp-summarize-01.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n\n## `group_by(cat2)`\n\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"video/grp-summarize-02.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\nLet's see what happens when we group with two columns:\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nbabynames |>\n  group_by(year, sex) |> \n  summarize(total = sum(n))\n\n\n```\n\n:::\n\nTo understand exactly what `group_by()` is doing, remove the line `group_by(year, sex) |>` from the code above and rerun it. How do the results change?\n\nThis animation should help with the intuition of grouping by two columns:\n\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"video/grp-summarize-03.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n\n### Ungrouping 1\n\nIf you apply `summarize()` to grouped data, `summarize()` will return data that is grouped in a similar, but not identical fashion. `summarize()` will remove the last variable in the grouping criteria, which creates a data frame that is grouped at a higher level. For example, this `summarize()` statement receives a data frame that is grouped by year and sex, but it returns a data frame that is grouped only by year.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  group_by(year, sex) |> \n  summarize(total = sum(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 276 × 3\n# Groups:   year [138]\n    year sex    total\n   <dbl> <chr>  <int>\n 1  1880 F      90993\n 2  1880 M     110491\n 3  1881 F      91953\n 4  1881 M     100743\n 5  1882 F     107847\n 6  1882 M     113686\n 7  1883 F     112319\n 8  1883 M     104627\n 9  1884 F     129020\n10  1884 M     114442\n# ℹ 266 more rows\n```\n\n\n:::\n:::\n\n\n\n### Ungrouping 2\n\nIf only one grouping variable is left in the grouping criteria, `summarize()` will return an ungrouped data set. This feature let's you progressively \"unwrap\" a grouped data set:\n\nIf we add another `summarize()` to our pipe, \n\n1.  our data set will first be grouped by year and sex.  \n1. _Then_ it will be summarized into a data set grouped by year (i.e. the result above)  \n1. _Then_ be summarized into a final data set that is not grouped.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  group_by(year, sex) |> \n  summarize(total = sum(n)) |> \n  summarize(total = sum(total))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 138 × 2\n    year  total\n   <dbl>  <int>\n 1  1880 201484\n 2  1881 192696\n 3  1882 221533\n 4  1883 216946\n 5  1884 243462\n 6  1885 240854\n 7  1886 255317\n 8  1887 247394\n 9  1888 299473\n10  1889 288946\n# ℹ 128 more rows\n```\n\n\n:::\n:::\n\n\n\n### Ungrouping 3\n\nIf you wish to manually remove the grouping criteria from a data set, you can do so with `ungroup()`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  group_by(year, sex) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,924,665 × 5\n    year sex   name          n   prop\n   <dbl> <chr> <chr>     <int>  <dbl>\n 1  1880 F     Mary       7065 0.0724\n 2  1880 F     Anna       2604 0.0267\n 3  1880 F     Emma       2003 0.0205\n 4  1880 F     Elizabeth  1939 0.0199\n 5  1880 F     Minnie     1746 0.0179\n 6  1880 F     Margaret   1578 0.0162\n 7  1880 F     Ida        1472 0.0151\n 8  1880 F     Alice      1414 0.0145\n 9  1880 F     Bertha     1320 0.0135\n10  1880 F     Sarah      1288 0.0132\n# ℹ 1,924,655 more rows\n```\n\n\n:::\n:::\n\n\n\n### Ungrouping 3\n\nAnd, you can override the current grouping information with a new call to `group_by()`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  group_by(year, sex) |> \n  group_by(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,924,665 × 5\n# Groups:   name [97,310]\n    year sex   name          n   prop\n   <dbl> <chr> <chr>     <int>  <dbl>\n 1  1880 F     Mary       7065 0.0724\n 2  1880 F     Anna       2604 0.0267\n 3  1880 F     Emma       2003 0.0205\n 4  1880 F     Elizabeth  1939 0.0199\n 5  1880 F     Minnie     1746 0.0179\n 6  1880 F     Margaret   1578 0.0162\n 7  1880 F     Ida        1472 0.0151\n 8  1880 F     Alice      1414 0.0145\n 9  1880 F     Bertha     1320 0.0135\n10  1880 F     Sarah      1288 0.0132\n# ℹ 1,924,655 more rows\n```\n\n\n:::\n:::\n\n\n\nThat's it. Between `group_by()`, `summarize()`, and `ungroup()`, you have a toolkit for taking groupwise summaries of your data at various levels of grouping.\n\n### The most popular names by total children\n\nYou now know enough to calculate the most popular names by total children (it may take some strategizing, but you can do it!). \n\nIn the code chunk below, use `group_by()`, `summarize()`, and `arrange()` to display the ten most popular names. Compute popularity as the total number of children of a single gender given a name. In other words, the total number of boys named \"Kelly\" should be computed separately from the total number of girls named \"Kelly\".\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |>\n  group_by(name, sex) |> \n  summarize(total = sum(n)) |> \n  arrange(desc(total))\n```\n\n:::\n\n\n### The history of the most popular names by total children\n\nLet's examine how the popularity of popular names has changed over time. To help us, I've made `top_10`, which is a version of `babynames` that is trimmed down to just the ten most popular names from above.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntop_10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,380 × 5\n    year sex   name        n    prop\n   <dbl> <chr> <chr>   <int>   <dbl>\n 1  1880 F     Mary     7065 0.0724 \n 2  1880 M     John     9655 0.0815 \n 3  1880 M     William  9532 0.0805 \n 4  1880 M     James    5927 0.0501 \n 5  1880 M     Charles  5348 0.0452 \n 6  1880 M     Joseph   2632 0.0222 \n 7  1880 M     Robert   2415 0.0204 \n 8  1880 M     David     869 0.00734\n 9  1880 M     Richard   728 0.00615\n10  1880 M     Michael   354 0.00299\n# ℹ 1,370 more rows\n```\n\n\n:::\n:::\n\n\n\n### Exercise: Proportions for popular names\n\nUse the code block below to plot a line graph of `prop` vs `year` for each name in `top_10`. Be sure to color the lines by name to make the graph interpretable.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\ntop_10 |>\n  ggplot() +\n    geom_line(aes(x = year, y = prop, color = name))\n```\n\n:::\n\n### Exercise: Total children for popular names\n\nNow use `top_10` to plot `n` vs `year` for each of the names. How are the plots different? Why might that be? How does this affect our decision to use total children as a measure of popularity?\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\ntop_10 |>\n  ggplot() +\n    geom_line(aes(x = year, y = n, color = name))\n```\n\n:::\n\n###\n\nGood job! This graph shows different trends than the one above, now let's consider why.\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n<a id=\"nextTopicButton\" class=\"btn btn-danger disabled\" href=\"04-mutate.html\" role=\"button\">Next topic</a>\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}