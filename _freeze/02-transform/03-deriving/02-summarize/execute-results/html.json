{
  "hash": "f554f18e053d6741f002266948c8ed25",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"`summarize()`\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - babynames\n    - dplyr\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n`summarize()` takes a data frame and uses it to calculate a new data frame of summary statistics. \n\n### Syntax\n\nTo use `summarize()`, pass it a data frame and then one or more named arguments. Each named argument should be set to an R expression that generates a single value. Summarise will turn each named argument into a column in the new data frame. The name of each argument will become the column name, and the value returned by the argument will become the column contents.\n\nImportantly, the `summarize()` function is *destructive*. It collapses a dataset into a single row and throws away any columns that we don’t use when summarizing. Watch this little animation to see what it does:\n\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"video/grp-summarize-00.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n\n### Example\n\nI used `summarize()` earlier to calculate the total number of boys named \"Andrew\", but let's expand that code to also calculate \n\n* `max`: the maximum number of boys named \"Andrew\" in a single year\n* `mean`: the mean number of boys named \"Andrew\" per year\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |> \n  filter(name == \"Andrew\", sex == \"M\") |> \n  summarize(total = sum(n), max = max(n), mean = mean(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n    total   max  mean\n    <int> <int> <dbl>\n1 1283910 36204 9304.\n```\n\n\n:::\n:::\n\n\n\nDon't let the code above fool you. The first argument of `summarize()` is always a data frame, but when you use `summarize()` in a pipe, the first argument is provided by the pipe operator, `|>`. Here the first argument will be the data frame that is returned by `babynames |> filter(name == \"Andrew\", sex == \"M\")`.\n\n### Exercise: `summarize()`\n\nUse the code chunk below to compute three statistics:\n\n1. the total number of children who ever had your name\n1. the maximum number of children given your name in a single year\n1. the mean number of children given your name per year \n\nIf you cannot think of an R function that would compute each statistic, click the Solution tab.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  filter(name == \"Andrew\", sex == \"M\") |> \n  summarize(total = sum(n), max = max(n), mean = mean(n))\n```\n\n:::\n\n\n### Summary functions\n\nSo far our `summarize()` examples have relied on `sum()`, `max()`, and `mean()`. But you can use any function in `summarize()` so long as it meets one criteria: the function must take a _vector_ of values as input and return a _single_ value as output. Functions that do this are known as **summary functions** and they are common in the field of descriptive statistics. Some of the most useful summary functions include:\n\n1. **Measures of location**: `mean(x)`, `median(x)`, `quantile(x, 0.25)`, `min(x)`, and `max(x)`\n1. **Measures of spread**: `sd(x)`, `var(x)`, `IQR(x)`, and `mad(x)`\n1. **Measures of position**: `first(x)`, `nth(x, 2)`, and `last(x)`\n1. **Counts**: `n_distinct(x)` and `n()`, which takes no arguments, and returns the size of the current group or data frame. \n1. **Counts and proportions of logical values**: `sum(!is.na(x))`, which counts the number of `TRUE`s returned by a logical test; `mean(y == 0)`, which returns the proportion of `TRUE`s returned by a logical test.\n\nLet's apply some of these summary functions. Click Continue to test your understanding. \n\n### Khaleesi challenge\n\n\"Khaleesi\" is a very modern name that appears to be based on the _Game of Thrones_ TV series, which premiered on April 17, 2011. In the chunk below, filter `babynames` to just the rows where `name == \"Khaleesi\"`. Then use `summarize()` and a summary function to return the first value of `year` in the data set.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  filter(name == \"Khaleesi\") |> \n  summarize(year = first(year))\n```\n\n:::\n\n\n### Distinct name challenge\n\nIn the chunk below, use `summarize()` and a summary function to return a data frame with two columns:\n\n* A column named `n` that displays the total number of rows in `babynames`\n* A column named `distinct` that displays the number of distinct names in `babynames`\n\nWill these numbers be different? Why or why not?\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  summarize(n = n(), distinct = n_distinct(name))\n```\n\n:::\n\n###\n\nGood job! The two numbers are different because most names appear in the data set more than once. They appear once for each year in which they were used.\n\n### `summarize()` by groups?\n\nHow can we apply `summarize()` to find the most popular names in `babynames`? You've seen how to calculate the total number of children that have your name, which provides one of our measures of popularity, i.e. the total number of children that have a name:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |> \n  filter(name == \"Andrew\", sex == \"M\") |> \n  summarize(total = sum(n))\n```\n:::\n\n\n\nHowever, we had to isolate your name from the rest of your data to calculate this number. You could imagine writing a program that goes through each name one at a time and: \n\n1. filters out the rows with just that name\n2. applies summarize to the rows\n\nEventually, the program could combine all of the results back into a single data set. However, you don't need to write such a program; this is the job of {dplyr}'s `group_by()` function.\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n<a id=\"nextTopicButton\" class=\"btn btn-danger disabled\" href=\"03-group_by.html\" role=\"button\">Next topic</a>\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}