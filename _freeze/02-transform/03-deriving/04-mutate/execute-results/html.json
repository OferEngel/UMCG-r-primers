{
  "hash": "273f6c3fb1b6942ca08a27346d2cd864",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"`mutate()`\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - babynames\n    - dplyr\n    - ggplot2\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n\n### The total number of children by year {.no-hide}\n\nWhy might there be a difference between the _proportion_ of children who receive a name over time, and the _number_ of children who receive the name?\n\nAn obvious culprit could be the total number of children born per year. If more children are born each year, the number of children who receive a name could grow even if the proportion of children given that name declines.\n\nTest this theory in the chunk below. Use `babynames` and groupwise summaries to compute the total number of children born each year and then to plot that number vs. year in a line graph.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  group_by(year) |> \n  summarize(n = sum(n)) |> \n  ggplot() +\n    geom_line(aes(x = year, y = n))\n```\n\n:::\n\n\n### Popularity based on rank\n\nThe graph above suggests that our first definition of popularity is confounded with population growth: the most popular names in 2015 likely represent far more children than the most popular names in 1880. The total number of children given a name may still be the best definition of popularity to use, but it will overweight names that have been popular in recent years.\n\nThere is also evidence that our definition is confounded with a gender effect: only one of the top ten names was a girl's name.\n\nIf you are concerned about these things, you might prefer to use our second definition of popularity, which would give equal representation to each year and gender:\n\n2. **Ranks**: A name is popular _if it consistently ranks among the top names from year to year_.\n\nTo use this definition, we could:\n\n1. Compute the rank of each name within each year and gender. The most popular name would receive the rank 1 and so on. \n2. Find the median rank for each name, accounting for gender. The names with the lowest median would be the names that \"consistently rank among the top names from year to year.\"\n\nTo do this, we will need to learn one last {dplyr} function.\n\n### `mutate()`\n\n`mutate()` uses a data frame to compute new variables. It then returns a copy of the data frame that includes the new variables. For example, we can use `mutate()` to compute a `percent` variable for `babynames`. Here percent is just the `prop` multiplied by 100 and rounded to two decimal places.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  mutate(percent = round(prop * 100, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,924,665 × 6\n    year sex   name          n   prop percent\n   <dbl> <chr> <chr>     <int>  <dbl>   <dbl>\n 1  1880 F     Mary       7065 0.0724    7.24\n 2  1880 F     Anna       2604 0.0267    2.67\n 3  1880 F     Emma       2003 0.0205    2.05\n 4  1880 F     Elizabeth  1939 0.0199    1.99\n 5  1880 F     Minnie     1746 0.0179    1.79\n 6  1880 F     Margaret   1578 0.0162    1.62\n 7  1880 F     Ida        1472 0.0151    1.51\n 8  1880 F     Alice      1414 0.0145    1.45\n 9  1880 F     Bertha     1320 0.0135    1.35\n10  1880 F     Sarah      1288 0.0132    1.32\n# ℹ 1,924,655 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWatch this animation to help with the intuition. `mutate()` adds a new column to the left side of the data frame:\n\n\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"video/mutate.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n\n\n### Exercise: `mutate()`\n\nThe syntax of mutate is similar to `summarize()`. `mutate()` takes first a data frame, and then one or more named arguments that are set equal to R expressions. `mutate()` turns each named argument into a column. The name of the argument becomes the column name and the result of the R expression becomes the column contents.\n\nUse `mutate()` in the chunk below to create a `births` column, the result of dividing `n` by `prop`. You can think of `births` as a sanity check; it uses each row to double check the number of boys or girls that were born each year. If all is well, the numbers will agree across rows (allowing for rounding errors).\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  mutate(births = n / prop)\n```\n\n:::\n\n### Vectorized functions\n\nLike `summarize()`, `mutate()` works in combination with a specific type of function. `summarize()` expects summary functions, which take vectors of input and return _single_ values. `mutate()` expects **vectorized functions**, which take vectors of input and return _vectors_ of values.\n\nIn other words, summary functions like `min()` and `max()` won't work well with `mutate()`. You can see why if you take a moment to think about what `mutate()` does: `mutate()` adds a new column to the original data set. In R, every column in a dataset must be the same length, so `mutate()` must supply as many values for the new column as there are in the existing columns. \n\nIf you give `mutate()` an expression that returns a single value, it will follow R's recycling rules and repeat that value as many times as needed to fill the column. This can make sense in some cases, but the reverse is never true: you cannot give `summarize()` a vectorized function; `summarize()` needs its input to return a single value.\n\nWhat are some of R's vectorized functions? Click Continue to find out.\n\n### The most useful vectorized functions\n\nSome of the most useful vectorised functions in R to use with `mutate()` include:\n\n1. **Arithmetic operators**: `+`, `-`, `*`, `/`, `^`. These are all vectorised, using R's so called \"recycling rules\". If one vector of input is shorter than the other, it will automatically be repeated multiple times to create a vector of the same length. \n1. **Modular arithmetic**: `%/%` (integer division) and `%%` (remainder)\n1. **Logical comparisons**, `<`, `<=`, `>`, `>=`, `!=`\n1. **Logs**: `log(x)`, `log2(x)`, `log10(x)`\n1. **Offsets**: `lead(x)`, `lag(x)`\n1. **Cumulative aggregates**: `cumsum(x)`, `cumprod(x)`, `cummin(x)`, `cummax(x)`, `cummean(x)`\n1. **Ranking**: `min_rank(x)`, `row_number(x)`, `dense_rank(x)`, `percent_rank(x)`, `cume_dist(x)`, `ntile(x)`\n\nFor ranking, I recommend that you use `min_rank()`, which gives the smallest values the top ranks. To rank in descending order, use the familiar `desc()` function, e.g.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmin_rank(c(50, 100, 1000))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nmin_rank(desc(c(50, 100, 1000)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 1\n```\n\n\n:::\n:::\n\n\n\n\n### Exercise: Ranks\n\nLet's practice by ranking the entire dataset based on `prop`. In the chunk below, use `mutate()` and `min_rank()` to rank each row based on its `prop` value, with the highest values receiving the top ranks.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  mutate(rank = min_rank(desc(prop)))\n```\n\n:::\n\n\n### Rankings by group\n\nIn the previous exercise, we assigned rankings across the entire data set. For example, with the exception of ties, there was only one 1 _in the entire data set_, only one 2, and so on. To calculate a popularity score across years, you will need to do something different: you will need to assign rankings within groups of year and sex. Now there will be one 1 _in each group of year and sex_.\n\nTo rank within groups, combine `mutate()` with `group_by()`. Like {dplyr}'s other functions, `mutate()` will treat grouped data in a group-wise fashion.\n\nWatch this animation to help with the intuition:\n\n\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"video/grp-mutate.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n\n\n###\n\nAdd `group_by()` to our code from above, to calculate ranking within year and sex combinations. Do you notice the numbers change?\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nbabynames |> \n  mutate(rank = min_rank(desc(prop)))\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  group_by(year, sex) |> \n  mutate(rank = min_rank(desc(prop)))\n```\n\n:::\n\n### The most popular names by yearly rankings\n\n`group_by()` provides the missing piece for calculating our second measure of popularity. In the code chunk below,\n\n1. Group `babynames` by `year` and `sex`\n1. Assign a rank to each name based on descending values of `prop`\n1. Regroup the data by `name` and `sex`\n1. Compute the median ranking for each name and sex combination\n1. Arrange the results so the names with the lowest sum appear at the top of the data set.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |> \n  group_by(year, sex) |> \n  mutate(rank = min_rank(desc(prop))) |> \n  group_by(name, sex) |> \n  summarize(score = median(rank)) |> \n  arrange(score)\n```\n\n:::\n\n###\n\nCongratulations! Our second provides a different picture of popularity. Here we see names that have been consistently popular over time, including new entries like Elizabeth and Thomas.\n\n\n### Recap\n\nIn this primer, you learned three functions for isolating data within a table: \n\n* `select()`\n* `filter()`\n* `arrange()`\n\nYou also learned three functions for deriving new data from a table: \n\n* `summarize()`\n* `group_by()`\n* `mutate()`\n\nTogether these six functions create a _grammar_ of data manipulation, a system of verbs that you can use to manipulate data in a sophisticated, step-by-step way. These verbs target the everyday tasks of data analysis. No matter which types of data you work with, you will discover that:\n\n1. _Data sets often contain more information than you need_\n1. _Data sets imply more information than they display_\n\nThe six dplyr functions help you work with these realities by isolating and revealing the information contained in your data. In fact, {dplyr} provides more than six functions for this grammar: {dplyr} comes with several functions that are variations on the themes of `select()`, `filter()`, `summarize()`, and `mutate()`. Each follows the same pipeable syntax that is used throughout dplyr. If you are interested, you can learn more about these peripheral functions in the [{dplyr} cheatsheet](https://rstudio.github.io/cheatsheets/html/data-transformation.html).\n\n##\n\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n<a id=\"nextTopicButton\" class=\"btn btn-danger disabled\" href=\"05-challenges.html\" role=\"button\">Next topic</a>\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}