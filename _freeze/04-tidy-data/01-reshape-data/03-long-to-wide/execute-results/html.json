{
  "hash": "d82ea3bbe998dbcc25ccb6c5dfba12e7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Long to wide\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n          <script src=\"/js/bootstrapify.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - tidyr\n    - dplyr\n    - ggplot2\n    - babynames\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n\n```{webr-r}\n#| context: setup\npollution <- tribble(\n       ~city,   ~size, ~amount,\n  \"New York\", \"large\",      23,\n  \"New York\", \"small\",      14,\n    \"London\", \"large\",      22,\n    \"London\", \"small\",      16,\n   \"Beijing\", \"large\",     121,\n   \"Beijing\", \"small\",     121\n)\n```\n\n### Narrow data {.no-hide}\n\nThe `pollution` dataset below displays the amount of small and large particulate in the air of three cities. It illustrates another common type of untidy data. **Narrow data** has a column whose values could be variable names in a tidy data frame and another column whose values would be values under these new columns. Can you tell here which is which?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npollution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  city     size  amount\n  <chr>    <chr>  <dbl>\n1 New York large     23\n2 New York small     14\n3 London   large     22\n4 London   small     16\n5 Beijing  large    121\n6 Beijing  small    121\n```\n\n\n:::\n:::\n\n\n\n\n### Quiz 4: Which is the column containing variable names?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npollution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  city     size  amount\n  <chr>    <chr>  <dbl>\n1 New York large     23\n2 New York small     14\n3 London   large     22\n4 London   small     16\n5 Beijing  large    121\n6 Beijing  small    121\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note appearance=\"simple\" icon=false .question}\n\n**Which column in `pollution` contains variable names?**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_41964\" onsubmit=\"return validate_form_41964()\" method=\"post\">\n<input type=\"radio\" name=\"answer_41964\" id=\"answer_41964_1\" value=\"city\"/>\n<label>city</label>\n<br/>\n<input type=\"radio\" name=\"answer_41964\" id=\"answer_41964_2\" value=\"size\"/>\n<label>size</label>\n<br/>\n<input type=\"radio\" name=\"answer_41964\" id=\"answer_41964_3\" value=\"amount\"/>\n<label>amount</label>\n<br/>\n<input type=\"submit\" value=\"Submit answer\"/>\n<div id=\"result_41964\"></div>\n</form>\n<script>function validate_form_41964() {var x, text; var x = document.forms['form_41964']['answer_41964'].value;if (x == 'size'){text = 'Correct! Two properties are being measured in this data: 1) the amount of small particulate in the air, and 2) the amount of large particulate.';} else {text = 'I have a different answer';} document.getElementById('result_41964').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1;res1 = document.getElementById('result_41964').innerText == 'Correct! Two properties are being measured in this data: 1) the amount of small particulate in the air, and 2) the amount of large particulate.';text = res1;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n:::\n\n\n\n:::\n\n\n### Quiz 5 - Which is the column containing values?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npollution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  city     size  amount\n  <chr>    <chr>  <dbl>\n1 New York large     23\n2 New York small     14\n3 London   large     22\n4 London   small     16\n5 Beijing  large    121\n6 Beijing  small    121\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note appearance=\"simple\" icon=false .question}\n\n**Which column in `pollution` contains the values associated with the variable names from the previous exercise?**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_75960\" onsubmit=\"return validate_form_75960()\" method=\"post\">\n<input type=\"radio\" name=\"answer_75960\" id=\"answer_75960_1\" value=\"city\"/>\n<label>city</label>\n<br/>\n<input type=\"radio\" name=\"answer_75960\" id=\"answer_75960_2\" value=\"size\"/>\n<label>size</label>\n<br/>\n<input type=\"radio\" name=\"answer_75960\" id=\"answer_75960_3\" value=\"amount\"/>\n<label>amount</label>\n<br/>\n<input type=\"submit\" value=\"Submit answer\"/>\n<div id=\"result_75960\"></div>\n</form>\n<script>function validate_form_75960() {var x, text; var x = document.forms['form_75960']['answer_75960'].value;if (x == 'amount'){text = 'Correct! What do these numbers represent? You can only tell when you match them with the variable names large (for large particulate) and small (for small particulate).';} else {text = 'I have a different answer';} document.getElementById('result_75960').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2;res1 = document.getElementById('result_41964').innerText == 'Correct! Two properties are being measured in this data: 1) the amount of small particulate in the air, and 2) the amount of large particulate.'; res2 = document.getElementById('result_75960').innerText == 'Correct! What do these numbers represent? You can only tell when you match them with the variable names large (for large particulate) and small (for small particulate).';text = res1 + res2;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n:::\n\n\n\n:::\n\n### A tidy version of `pollution`\n\n::: {.callout-tip}\n## Older names\n\nThis video uses older function names:\n\n- Old `gather()` is now `pivot_longer()`\n- Old `spread()` is now `pivot_wider()`\n:::\n\nWatch [this video](https://vimeo.com/229581273):\n\n\n\n\n```{=html}\n<div class=\"ratio ratio-4x3\">\n<iframe src=\"https://player.vimeo.com/video/229581273\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen></iframe>\n</div>\n```\n\n\n\n\n### `pivot_wider()`\n\nYou can reshape this dataset into a wider dataset with the `pivot_wider()` function in the {tidyr} package. To use `pivot_wider()` pass it the name of a dataset to pivot (provided here by the pipe `|>`). Then tell it which column contains names and which contains values.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npollution |>\n  pivot_wider(\n    names_from = size,\n    values_from = amount\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  city     large small\n  <chr>    <dbl> <dbl>\n1 New York    23    14\n2 London      22    16\n3 Beijing    121   121\n```\n\n\n:::\n:::\n\n\n\n\n`pivot_wider()` will give each unique value in the `names_from` column its own column. The unique values from this column will become the new column names. `pivot_wider()` will then redistribute the values in the `values_from` column across the new columns in a way that preserves every relationship in the original dataset. \n\n### Exercise 3: Tidy table2\n\nUse `pivot_wider()` to tidy `table2` into a dataset with four columns: `country`, `year`, `cases`, and `population`. In short, convert `table2` to look like `table1`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n\n\n:::\n\n```{.r .cell-code}\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\ntable2 |> \n  pivot_wider(\n    names_from = type, \n    values_from = count\n  )\n```\n\n:::\n\n###\n\nGood job! You now possess two complementary tools for reshaping the layout of data. By iterating between `pivot_longer()` and `pivot_wider()` you can rearrange the values of any data set into many different configurations.\n\n### To quote or not to quote\n\nYou may notice that both `pivot_longer()` and `pivot_wider()` arguments that start with _names_ and _values_. And, in each case the arguments are set to column names. But in `pivot_longer()` you must surround the names with quotes and in `pivot_wider()` case you do not. Why is this?\n\n```r\ntable4b |> \n  pivot_longer(\n    cols = -country, \n    names_to = \"year\", values_to = \"population\"\n  )\n\npollution |> \n  pivot_wider(names_from = size, values_from = amount)\n```\n\nDon't let the difference trip you up. Instead think about what the quotes mean. \n\n* In R, any sequence of characters surrounded by quotes is a character string, which is a piece of data in and of itself. \n* Likewise, any sequence of characters not surrounded by quotes is the name of an object, which is a symbol that contains or points to a piece of data. Whenever R evaluates an object name, it searches for the object to find the data that it contains. If the object does not exist somewhere, R will return an error.\n\n###  \n\nIn our `pivot_longer()` code above, \"year\" and \"population\" refer to two columns that do not yet exist. If R tried to look for objects named _year_ and _population_ it wouldn't find them (at least not in the `table4b` dataset). When we use `pivot_longer()` we are passing R two values (character strings) to use as the name of future columns that will appear in the result.\n\nIn our `pivot_wider()` code, `names_from` and `values_from` point to two columns that _do_ exist in the `pollution` dataset: `size` and `amount.` When we use `pivot_wider()`, we are telling R to find these objects (columns) in the dataset and to use their contents to create the result. Since they exist, we do not need to surround them in quotation marks.\n\nIn practice, whether or not you need to use quotation marks will depend on how the author of your function wrote the function. For example, `pivot_wider()` will still work if you do include quotation marks. However, you can use the intuition above as a guide for how to use functions in the tidyverse.\n\n### Boys and girls in {babynames}\n\nLet's apply `pivot_wider()` to a real world inquiry. The plot below visualizes an aspect of the `babynames` data set from the **babynames** package. (See [Work with Data](/02-transform/01-tibbles/01-babynames.qmd) for an introduction to the `babynames` dataset.)\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](03-long-to-wide_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nThe ratio of girls to boys in `babynames` is not constant across time. We can explore this phenomenon further by recreating the data in the plot.\n\n### Review: Make the data\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](03-long-to-wide_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nTo make the data displayed in the plot above, I first grouped babynames by `year` and `sex`. Then I computed a summary for each group: `total`, which is equal to the sum of `n` for each group.\n\nUse {dplyr} functions to recreate this process in the chunk below.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nbabynames\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |>\n  group_by(year, sex) |> \n  summarise(total = sum(n))\n```\n\n:::\n\n###\n\nGood job! Now that we have the data, let's recreate the plot.\n\n\n### Review: Make the plot\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-long-to-wide_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nUse the data below to make the plot above, which was built with {ggplot2} functions.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nbabynames |>\n  group_by(year, sex) |> \n  summarise(total = sum(n))\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |>\n  group_by(year, sex) |> \n  summarise(total = sum(n)) |> \n  ggplot() +\n  geom_line(aes(year, total, color = sex))\n```\n\n:::\n\n###\n\nGood job! You can see that the data shows that fewer boys than girls were born for the years prior to 1936, and fewer girls than boys for the years after 1936.\n\n\n### A better way to look at the data\n\nA better way to explore this phenomena would be to directly plot a ratio of boys to girls over time. To make such a plot, you would need to compute the ratio of boys to girls for each year from 1880 to 2015:\n\n$$\n\\text{ratio male} = \\frac{\\text{total male}}{\\text{total female}}\n$$\n\nBut how can we plot this data? Our current iteration of `babynames` places the total number of boys and girls for each year in the same column, which makes it hard to use both totals in the same calculation.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  group_by(year, sex) |> \n  summarise(total = sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 276 × 3\n# Groups:   year [138]\n    year sex    total\n   <dbl> <chr>  <int>\n 1  1880 F      90993\n 2  1880 M     110491\n 3  1881 F      91953\n 4  1881 M     100743\n 5  1882 F     107847\n 6  1882 M     113686\n 7  1883 F     112319\n 8  1883 M     104627\n 9  1884 F     129020\n10  1884 M     114442\n# ℹ 266 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### A goal\n\nIt would be easier to calculate the ratio of boys to girls if we could reshape our data to place the total number of boys born per year in one column and the total number of girls born per year in another:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 138 × 3\n# Groups:   year [138]\n    year      F      M\n   <dbl>  <int>  <int>\n 1  1880  90993 110491\n 2  1881  91953 100743\n 3  1882 107847 113686\n 4  1883 112319 104627\n 5  1884 129020 114442\n 6  1885 133055 107799\n 7  1886 144533 110784\n 8  1887 145981 101413\n 9  1888 178622 120851\n10  1889 178366 110580\n# ℹ 128 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThen we could compute the ratio by piping our data into a call like `mutate(ratio = M / F)`.\n\n### Exercise 4: Make the plot\n\nAdd to the code below to:\n\n1. Reshape the layout to place the total number of boys per year in one column and the total number of girls born per year in a second column.\n1. Compute the ratio of boys to girls.\n1. Plot the ratio of boys to girls over time.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\nbabynames |>\n  group_by(year, sex) |> \n  summarise(total = sum(n))\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\nbabynames |>\n  group_by(year, sex) |> \n  summarise(total = sum(n)) |>\n  pivot_wider(\n    names_from = sex,\n    values_from = total\n  ) |>\n  mutate(ratio = M / F) |>\n  ggplot(aes(year, ratio)) + \n  geom_line()\n```\n\n:::\n\n###\n\nGood job!\n\n\n### Interesting\n\nOur results reveal a conspicuous oddity, that is easier to interpret if we turn the ratio into a percentage.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  group_by(year, sex) |> \n  summarise(total = sum(n)) |>\n  pivot_wider(\n    names_from = sex,\n    values_from = total\n  ) |>\n  mutate(percent_male = M / (M + F) * 100, ratio = M / F) |>\n  ggplot(aes(year, percent_male)) + \n  geom_line()\n```\n\n::: {.cell-output-display}\n![](03-long-to-wide_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nThe percent of recorded male births is unusually low between 1880 and 1936. What is happening? One insight is that the data comes from the United States Social Security office, which was only created in 1936. As a result, we can expect the data prior to 1936 to display a survivorship bias.\n\n### Recap\n\nYour data will be easier to work with in R if you reshape it into a tidy layout at the start of your analysis. Data is tidy if:\n\n1. Each variable is in its own column\n1. Each observation is in its own row\n1. Each value is in its own cell\n\nYou can use `pivot_longer()` and `pivot_wider()`, or some iterative sequence of the two, to reshape your data into any possible configuration that:\n\n1. Retains all of the values in your original data set, and\n1. Retains all of the relationships between values in your original data set.\n\nIn particular, you can use these functions to recast your data into a tidy layout.\n\n### Food for thought\n\nIt is not always clear whether or not a data set is tidy. For example, the version of `babynames` that was tidy when we wanted to plot total children by year, was no longer tidy when we wanted to compute the ratio of male to female children.\n\nThe ambiguity comes from the definition of tidy data. Tidiness depends on the variables in your data set. But what is a variable depends on what you are trying to do.\n\nTo identify the variables that you need to work with, describe what you want to do with an equation. Each variable in the equation should correspond to a variable in your data.\n\nSo in our first case, we wanted to make a plot with the following mappings (e.g. equations)\n\n$$\n\\begin{aligned}\n\\text{x} &= \\text{year} \\\\\n\\text{y} &= \\text{total} \\\\\n\\text{color} &= \\text{sex}\n\\end{aligned}\n$$\n\nTo do this, we needed a dataset that placed $\\text{year}$, $\\text{total}$, and $\\text{sex}$ each in their own columns.\n\nIn our second case we wanted to compute $\\text{ratio male}$, where \n\n$$\n\\text{ratio male} = \\frac{\\text{total male}}{\\text{total female}}\n$$\n\nThis formula has three variables: $\\text{ratio male}$, $\\text{total male}$, and $\\text{total female}$. To create the first variable, we required a dataset that isolated the second and third variables ($\\text{total male}$ and $\\text{total female}$) in their own columns. \n\n\n##\n\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [
      "03-long-to-wide_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}