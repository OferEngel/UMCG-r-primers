{
  "hash": "89156b183582a555ff3b60d75c549144",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Wide to long\"\nformat:\n  html: \n    toc: false\n    section-divs: true\n    include-after-body: \n      - text: |\n          <script src=\"/js/progressive-reveal.js\"></script>\n          <script src=\"/js/bootstrapify.js\"></script>\n\nengine: knitr\nfilters:\n  - webr\nwebr:\n  packages:\n    - tidyr\n    - dplyr\n  cell-options:\n    editor-font-scale: 0.85\n    fig-width: 6\n    fig-height: 3.7\n    out-width: \"70%\"\n---\n\n\n\n\n\n\n```{webr-r}\n#| context: setup\ncases <- tribble(\n  ~Country, ~\"2011\", ~\"2012\", ~\"2013\",\n      \"FR\",    7000,    6900,    7000,\n      \"DE\",    5800,    6000,    6200,\n      \"US\",   15000,   14000,   13000\n)\n\ncases2 <- tribble(\n  ~city, ~country,  ~continent,     ~\"2011\", ~\"2012\", ~\"2013\",\n  \"Paris\",    \"FR\", \"Europe\",           7000,    6900,    7000,\n  \"Berlin\",   \"DE\", \"Europe\",           5800,    6000,    6200,\n  \"Chicago\",  \"US\", \"North America\",   15000,   14000,   13000\n)\n```\n\n### Untidy data {.no-hide}\n\n> \"Tidy data sets are all alike; but every messy data set is messy in its own way.\"\n> \n> --- Hadley Wickham\n\nHow you tidy an untidy data set will depend on the initial configuration of the data. For example, consider the `cases` data set below.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncases\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  Country `2011` `2012` `2013`\n  <chr>    <dbl>  <dbl>  <dbl>\n1 FR        7000   6900   7000\n2 DE        5800   6000   6200\n3 US       15000  14000  13000\n```\n\n\n:::\n:::\n\n\n\n\n### Quiz 3: What are the variables?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncases\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  Country `2011` `2012` `2013`\n  <chr>    <dbl>  <dbl>  <dbl>\n1 FR        7000   6900   7000\n2 DE        5800   6000   6200\n3 US       15000  14000  13000\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note appearance=\"simple\" icon=false .question}\n\n**What are the variables in `cases`?**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_41964\" onsubmit=\"return validate_form_41964()\" method=\"post\">\n<input type=\"radio\" name=\"answer_41964\" id=\"answer_41964_1\" value=\"Country, 2011, 2012, and 2013\"/>\n<label>Country, 2011, 2012, and 2013</label>\n<br/>\n<input type=\"radio\" name=\"answer_41964\" id=\"answer_41964_2\" value=\"Country, year, and some unknown quantity (n, count, number of cases, etc.)\"/>\n<label>Country, year, and some unknown quantity (n, count, number of cases, etc.)</label>\n<br/>\n<input type=\"radio\" name=\"answer_41964\" id=\"answer_41964_3\" value=\"FR, DE, and US\"/>\n<label>FR, DE, and US</label>\n<br/>\n<input type=\"submit\" value=\"Submit answer\"/>\n<div id=\"result_41964\"></div>\n</form>\n<script>function validate_form_41964() {var x, text; var x = document.forms['form_41964']['answer_41964'].value;if (x == 'Country, year, and some unknown quantity (n, count, number of cases, etc.)'){text = 'Correct!';} else {text = 'I have a different answer';} document.getElementById('result_41964').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1;res1 = document.getElementById('result_41964').innerText == 'Correct!';text = res1;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n:::\n\n\n\n:::\n\n### A tidy version of `cases`\n\n::: {.callout-tip}\n## Older names\n\nThis video uses older function names:\n\n- Old `gather()` is now `pivot_longer()`\n- Old `spread()` is now `pivot_wider()`\n:::\n\nWatch [this video](https://vimeo.com/229581247) (you'll need to click on the link; the video's privacy settings make it so it can't be embedded here)\n\n### `pivot_longer()`\n\nYou can use the `pivot_longer()` function in the {tidyr} package to convert wide data to long data. Notice that `pivot_longer()` returns a tidy copy of the dataset, but does not alter the original dataset. If you wish to use this copy later, you'll need to save it somewhere.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncases |> \n  pivot_longer(\n    cols = c(`2011`, `2012`, `2013`), \n    names_to = \"year\", \n    values_to = \"n\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 3\n  Country year      n\n  <chr>   <chr> <dbl>\n1 FR      2011   7000\n2 FR      2012   6900\n3 FR      2013   7000\n4 DE      2011   5800\n5 DE      2012   6000\n6 DE      2013   6200\n7 US      2011  15000\n8 US      2012  14000\n9 US      2013  13000\n```\n\n\n:::\n:::\n\n\n\n\nLet's take a closer look at the `pivot_longer()` syntax.\n\n### `pivot_longer()` syntax\n\nHere's the same call written without the pipe operator, which makes the syntax easier to see.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npivot_longer(\n  cases, \n  cols = c(`2011`, `2012`, `2013`), \n  names_to = \"year\", \n  values_to = \"n\"\n)\n```\n:::\n\n\n\n\nTo use `pivot_longer()`, pass it the name of a data set to reshape followed by which columns to pivot longer, the name of a new variable that will contain on the names of these columns as values, and the name of another new variables that will contain the values from these columns:\n\n* the `cols` argument contains the name of the columns to pivot into longer format.\n* the `names_to` argument is a string specifying the name of the new column to create from the data stored in the column names of the dataset to be reshaped.\n* the `values_to` argument is a string specifying the name of the new column to create from the data stored in cell values.\n\nAny unspecified columns will remain in the dataset, their contents repeated as often as necessary to duplicate each relationship in the original untidy data set.\n\n### Names and values\n\nIn a tidy data set, you will find variable names in the column names of the data set. The values will appear in the cells of the columns. Here we organize the year information originally stored across multiple columns in the dataset into a single column called year. This arrangement reduces duplication.\n\nSometimes you will also find pairs of names and values listed beside each other in two separate columns, as in `table2`. Here the `type` column lists the names that are associated with the `count` column. This layout is sometimes called \"narrow\" data.\n\nThe pivot functions rely on this notion of names and values to describe what should go where. In `pivot_longer()` the `names_to` argument describes the new column that contains the values that previously appeared where a tidy data frame's variable names would go. The `values_to` argument describes the new column that contains the values that previously appeared in the value positions, e.g. in cells.\n\n### Exercise 1: Tidy `table4a`\n\nNow that you've seen `pivot_longer()` in action, try using it to tidy `table4a`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n\n\n\nThe result should contain three columns: `country`, `year`, and `cases`. Begin by modifying our code below.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\ncases |> \n  pivot_longer(\n    cols = c(`2011`, `2012`, `2013`), \n    names_to = \"year\", values_to = \"n\"\n  )\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\ntable4a |> \n  pivot_longer(\n    cols = c(`1999`, `2000`), \n    names_to = \"year\", \n    values_to = \"cases\"\n  )\n```\n\n:::\n\n###\n\nGood job!\n\n### Specifying columns\n\nSo far, we have listed which columns to pivot by naming them one at a time and combining them using the `c()` function, but this isn't necessary. `pivot_longer()` also recognizes column names as well as all of the `select()` helpers that you learned about in [Isolating Data with {dplyr}](/02-transform/02-isolating/02-select.qmd). So, for example, these expressions would all do the same thing: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable4a |> \n  pivot_longer(\n    cols = c(`1999`, `2000`), \n    names_to = \"year\", values_to = \"cases\"\n  )\n\ntable4a |> \n  pivot_longer(\n    cols = -country, \n    names_to = \"year\", values_to = \"cases\"\n  )\n\ntable4a |> \n  pivot_longer(\n    cols = one_of(c(\"1999\", \"2000\")), \n    names_to = \"year\", values_to = \"cases\"\n  )\n```\n:::\n\n\n\n\nNotice that 1999 and 2000 are numbers. When you directly call column names that are numbers, you need to surround the names with backticks (otherwise `pivot_longer()` would think you mean the 1999th and 2000th columns). Use `?select_helpers` to open a help page that lists the select helpers.\n\n### Exercise 2: Tidy `table4b`\n\nUse `pivot_longer()` and the `-` helper to tidy `table4b` into a dataset with three columns: `country`, `year`, and `population`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable4b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country         `1999`     `2000`\n  <chr>            <dbl>      <dbl>\n1 Afghanistan   19987071   20595360\n2 Brazil       172006362  174504898\n3 China       1272915272 1280428583\n```\n\n\n:::\n:::\n\n\n\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\ntable4b |> \n  pivot_longer(\n    cols = -country, \n    names_to = \"year\", \n    values_to = \"population\"\n  )\n```\n\n:::\n\n###\n\nGood job! Together the tidy versions of `table4a` and `table4b` repeat the information in `table1.` In [Join Data Sets]() you will learn how to combine them back into a single data set.\n\n### Converting output\n\nIf you looked closely at your results in the previous exercises, you may have noticed something odd: the new `year` column is a character vector. You can tell because R displays `<chr>` beneath the column name. The `names_transform` and `values_transform` arguments take a list of functions that define how to transform the newly created column defining the desired type of each newly created column.\n\nFor example, `names_transform = list(week = as.integer)` would convert a character variable called `week` to an integer.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\ntable4b |> \n  pivot_longer(\n    cols = -country, \n    names_to = \"year\", \n    values_to = \"population\"\n  )\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\ntable4b |> \n  pivot_longer(\n    cols = -country, \n    names_to = \"year\", \n    values_to = \"population\", \n    names_transform = list(year = as.integer)\n  )\n```\n\n:::\n\n###\n\nGood Job! Now `<int>` appears under the year column, which means that R has stored the years as integers instead of character strings. Integers are one of R's two numeric data types, along with doubles.\n\n### The flexibility of `pivot_longer()`\n\n`cases`, `table4a`, and `table4b` are all rectangular tables: \n\n* each row corresponds to the value of a variable, and\n* each column corresponds to the value of a variable\n\nRectangular tables are a simple form of wide data. But you will also encounter more complicated examples of wide data. For example, it is common for researchers to place one subject per row. In this case, you might see several columns of identifying information followed by a set of columns that list repeated measurements of the same variable. `cases2` emulates such a data set. \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncases2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  city    country continent     `2011` `2012` `2013`\n  <chr>   <chr>   <chr>          <dbl>  <dbl>  <dbl>\n1 Paris   FR      Europe          7000   6900   7000\n2 Berlin  DE      Europe          5800   6000   6200\n3 Chicago US      North America  15000  14000  13000\n```\n\n\n:::\n:::\n\n\n\n\nTo tidy this data, you would want to keep the first three columns as they are. Can you tidy this data with `pivot_longer()`? Yes, and you already know how. Think about the problem and then tidy `cases2` into a data set with five columns: `city`, `country`, `continent`, `year` (as an integer), and `cases`.\n\n::: {.panel-tabset}\n## {{< fa code >}}&ensp;Interactive editor\n\n```{webr-r}\n\n\n\n```\n\n## {{< fa circle-check >}}&ensp;Solution\n\n```r\ncases2 |> \n  pivot_longer(\n    cols = c(`2011`, `2012`, `2013`),\n    names_to = \"year\",\n    values_to = \"cases\",\n    names_transform = list(year = as.integer)\n  )\n```\n\n:::\n\n###\n\nGreat job! Now let's look at how to tidy another common type of untidy data.\n\n##\n\n\n\n\n::: {.cell layout-align=\"center\"}\n<section id=\"buttons\">\n<button id=\"continueButton\" class=\"btn btn-primary float-start me-2\">Continue</button>\n<a id=\"nextTopicButton\" class=\"btn btn-danger disabled\" href=\"03-long-to-wide.qmd\" role=\"button\">Next topic</a>\n<button id=\"resetButton\" class=\"btn btn-outline-warning btn-sm float-end\">Start over</button>\n</section>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}